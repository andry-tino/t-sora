---
layout: post
title:  "Tutorial"
date:   2016-10-16 19:13:00 +0000
categories: post
description: Main tutorial for building a cross platform app
---
# Building a 3D Earth and Moon animation
In this tutorial you will learn how to use [HTML5](https://en.wikipedia.org/wiki/HTML5), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), the [WebGL API](https://en.wikipedia.org/wiki/WebGL) and the [THREE library](https://threejs.org/) to create a 3D animation in your browser.

## Requirements
For this tutorial you are going to need:

1. An Internet browser. [Chrome](https://www.google.com/chrome/browser/desktop/index.html) is recommended because it has an easy way to disable [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) and a tutorial is provided here for that.
2. A text editor. [Visual Studio Code](https://code.visualstudio.com) is recommended because it has very good code highlight features and can be installed on all systems.

**Important** The browser you use must be updated to the latest version. We are going to use some very new functionalities introduced lately, so we need the latest version.

## A few things first...
Creating a 3D animation using Javascript and the WebGL API requires some code. In particular there is a lot of code for setting the basic stuff needed for whatever 3D project, namely a scene, a camera and some lights. Setting all these initial things together takes a lot of time and the WebGL API are very low level (every single point in a mesh is to be defined and a lot of matrix calculus is involved).

**THREE.js to the rescue** For this reason, we use a high level library called [THREE.js](https://threejs.org/) which hides all the mathematics behind objects and animations and lets us focus on the cool things. Thanks to this library, we are going to write much shorter code, making it easy to create objects and animate them.

**Preset pieces** Another detail to be aware of is that we are going to use a few snippets of code already prepared for you for some functionalities we are going to need. We could go though this code and build it together, but that would require some more time spent on a few minor things we don't want to focus on in the context of this tutorial. So we are just going to import and use it and that's all!

This tutorial also comes with some images we are going to use as well. They are going to be required once we start defining the material of the objects we'll create later.

## Defining the project structure
We start by creating the project structure with the folders and files we are going to need.

1. Go to this tutorial's source [Releases Git page](https://github.com/andry-tino/t-sora/releases).
2. Locate the latest Tutorial Kit and click on it.
3. In `Downloads`, locate the kit package (the other links contain the source code, don't choose them).
4. In your system, locate a place where you want to create the project. Usually your user's home folder in Linux and iOS, or the `Documents` folder in Windows are good choices.
2. Extract the package content there.

You should end up having the following folder structure:

```
+sora
|--+common
   |--shading.js
   |--utils.js
|--+deps
   |--three.js
|--+images
```

### Preset files
This is our start point. Inside the `sora` folder, there is all we need to start building our project.

| Path | Type | Description |
|------|:----:|-------------|
| `sora/common` | Folder | Contains all the common resources we will need |
| `sora/deps`   | Folder | Contains external libraries |
| `sora/images` | Folder | Contains the images and textures we need for materials |
| `common/shading.js` | JavaScript source | Has functions we will use for special 3D effects |
| `common/utils.js` | JavaScript source | Has some JavaScript utility functions for creating some complicated objects |
| `deps/three.js` | JavaScript source | The [THREE library](https://threejs.org/) |

### Completing the structure
The tutorial kit we just unpacked contains the initial set of folders and files we need. Now we need to start adding our stuff as, in this condition, we just have a few building blocks which do nothing.

#### Defining the homepage
We need to create the homepage of our project which will display the animation.

1. In your system, naivgate to directory `sora`.
2. Inside it, create a new directory called `earth`.
3. Inside `earth`, create 3 files called: `index.html`, `index.js` and `index.css`. Leave the files empty.

The folder structure should look like the following:

```
+sora
|--+earth
   |--index.html
   |--index.js
   |--index.css
```

We have basically created the initial structure for the homepage:

| File | Type | Description |
|------|:----:|-------------|
| `index.html` | HTML file | The homepage hosting the 3D animation |
| `index.js`   | JavaScript source file | The JavaScript source which will contain the code for creating the animation |
| `index.css` | CSS style source file | The style file for setting a few properties of the homepage |

#### Adding content
Let's now open `index.html`, and let's write the most basic HTML structure that every page needs to be correctly displayed in a browser:

{% highlight html linenos %}
<html>
  <head>
    <title>My first Three.js app</title>
  </head>
  <body>
	
  </body>
</html>
{% endhighlight %}

If you open this page in your browser, you will see just a blank page. We need to add some more stuff into it. So, inside the `<head>` tag, just under the `<title>`, add this line:

{% highlight html %}
<meta http-equiv="Access-Control-Allow-Origin" content="*">
{% endhighlight %}

This line is not simple to explain. For now, let's say that we need it in order to see the 3D animation once we create it. The browser will not authorize the 3D rendering without this line because of some secutity-related issues. This line will allow us to run the animation and see it on the browser.

We now need to add a reference to `index.css`, our stylesheet. So after the line we just typed, let's add these lines:

{% highlight html %}
<!-- The basic page style -->
<link rel="stylesheet" type="text/css" href="style.css">
{% endhighlight %}

This will allow us to import the content of `index.css` into our page.

Next step is to import some JavaScript files, we need to import `index.js`, `shading.js` and `utils.js` (the last 2 reside in the `common` folder). So let's add these lines after the lines we entered before:

{% highlight html %}
<!-- Stuff we need: external libraries and help scripts -->
<script type="text/javascript" src="../deps/three.js"></script>
<script type="text/javascript" src="../common/utils.js"></script>
<script type="text/javascript" src="../common/shading.js"></script>
{% endhighlight %}

We have imported the THREE library and some other files we will need later. However, we are missing one file: `index.js` which we need to import because, later, we will add the JavaScript code for the animation there. So let's add this final line of code after those we have just written a while ago:

{% highlight html %}
<!-- Our code -->
<script type="text/javascript" src="index.js"></script>
{% endhighlight %}

We are done for now with `index.html` which should look like this:

{% highlight html linenos %}
<html>
  <head>
    <title>My first Three.js app</title>

    <!-- The basic page style -->
    <link rel="stylesheet" type="text/css" href="style.css">

    <!-- Stuff we need: external libraries and help scripts -->
    <script type="text/javascript" src="../deps/three.js"></script>
    <script type="text/javascript" src="../common/utils.js"></script>
    <script type="text/javascript" src="../common/shading.js"></script>

    <!-- Our code -->
    <script type="text/javascript" src="index.js"></script>
  </head>
  <body>

  </body>
</html>
{% endhighlight %}

### A few styling settings
Before deep diving into the JavaScript code, let's first make sure that the 3D scenen we are going to build takes all the browser window's size. To do so, let's open `index.css` (which we just imported into `index.html`) and type in the following code:

{% highlight css linenos %}
body {
  margin: 0;
}

canvas { 
  width: 100%; 
  height: 100%;
}
{% endhighlight %}

This instructs the browser not to create the border margin. Also it instructs it to make the `<canvas>` element fill the entire space once we place it there. The `<canvas>` is something we are going to create later, basically it will contain the 3D world we are going to create.

## Building the 3D scene
Now that `index.html` is importing everything we need and we also have the correct style in place, we can start writing down the logic for building the animation. So, we start by opening `index.js` and typing in the following lines:

{% highlight javascript %}
window.addEventListener("load", function() {
  // Our code goes here
});
{% endhighlight %}

Function `addEventListener` will wait that the page loads before running the code inside the anonymous function passed in as second argument. As the comment is showing, we will write our code inside that anonymous function, so that we are certain that the page has finished loading all the imports and the style, before we create our 3D scene.

### Creating the renderer
We start by creating an instance of the [WebGL Renderer](https://threejs.org/docs/api/renderers/WebGLRenderer.html). The renderer is the component responsible for drawing the 3D scene. It is a pretty complex entity as it does all the magic. The renderer is responsible for:

- Drawing the scene.
- Drawing the objects in a scene.
- Evaluate materials.
- Evaluate light sources and shadows.
- Run a complex algorithm which calculates the amount of light on surfaces depending on the light sources and how light reflects on surfaces.

We create a renderer by invoking this command (we type it inside the anonymous function):

{% highlight javascript %}
var renderer = new THREE.WebGLRenderer({
  antialias : true
});
{% endhighlight %}

Variable `renderer` will host the component. Note that we set antialiasing so that the quality of our animation is higher.
The next three lines of code are as follows:

{% highlight javascript %}
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
{% endhighlight %}

In the first one we set the size of the scene basically, we make it span the whole window (both horizontally and vertically). The second line is actually adding the renderer to the page. If we do not add the renderer to the page, we won't be seeing anything otherwise. The last line will enable shadows.

Before moving to the next component, we need to create an array:

{% highlight javascript %}
var onRenderFcts = [];
{% endhighlight %}

This array will be used later and is very important as it will host the functions that the renderer should call in order to run the final animation.

### Creating the scene
We cannot create objects inside the renderer, we need to create a scene and add it to the renderer first. Later on, we will add objects to the scene.

{% highlight javascript %}
var scene = new THREE.Scene();
{% endhighlight %}

Now that the scene is ready, we can create a camera. If we do not create a camera, we cannot nothing on the screen. Cameras are the objects necessary to visualize whatever we place in a scene.

{% highlight javascript %}
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.z = 1;
{% endhighlight %}

The parameters we just passed to the [PerspectiveCamera](https://threejs.org/docs/api/cameras/PerspectiveCamera.html) object are the following (in order from left to right):

| Argument | Type | Description |
|----------|:----:|-------------|
| Frustum length | Number | The field volume that the camera captures. The camera will visualize only the objects falling into this volume |
| Perspective | Number | The perspective ratio |
| Frustum near plane | Number | The frustum plane which is closest to the viewpoint |
| Frustum far plane | Number |  The frustum plane which is farthest to the viewpoint |

The second line makes sure that the camera is positioned one unit above the base plane.

### Let's try to run it!
What if we wanted to see the effect of what we are building? Well, the only thing we need to do is telling `renderer` to paint the scene from a camera. Type the following line of code, save and then run the page in the browser:

{% highlight javascript %}
renderer.render(scene, camera);
{% endhighlight %}

What can you see? I bet you get a black screen :) We'll get to that, for now just remove the last line you wrote!

## Lighting it up
We have a scene and we also have a camera. But if we run this we are going to see only a black screen. Why? Because we are missing the most important thing when it comes to 3D computing: light. With no light, we only have darkness.

Following from the last line of code we wrote in the previous section, we now add these lines:

{% highlight javascript %}
var light = new THREE.AmbientLight(0x222222);
scene.add(light);
{% endhighlight %}

We are creating, in the first line, an [AmbientLight](https://threejs.org/docs/api/lights/AmbientLight.html) object. Think of this as an omnidirectional light. We are setting this to be a dark light because we want our background to be dark, the universe is not so bright after all. The last line is adding the light to the scene.

Our next step is creating a directional light which will point to the planet we will create later. A directional light is like a flashlight, so we will need to specify direction and intensity:

{% highlight javascript linenos %}
light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
light.castShadow = true;
light.shadow.camera.near = 0.01;
light.shadow.camera.far = 15;
light.shadow.camera.fov = 45;
light.shadow.camera.left = -1;
light.shadow.camera.right = 1;
light.shadow.camera.top = 1;
light.shadow.camera.bottom = -1;
light.shadow.bias = 0.001;
light.shadow.mapSize.width = 1024;
light.shadow.mapSize.height = 1024;
scene.add(light);
{% endhighlight %}

As you can see, the code we just wrote is setting a few properties for this [DirectionalLight](https://threejs.org/docs/api/lights/DirectionalLight.html) object:

| Property | Type | Description |
|----------|:----:|-------------|
| `position` | Coordinates | The point were the light will be placed |
| `castShadow` | Boolean | Should the light cast shadows? |
| `shadow.camera.near` | Number | The near plane defining the frustum of the shadow |
| `shadow.camera.far` | Number | The far plane defining the frustum of the shadow |
| `shadow.camera.fov` | Number | The field of view (vertical angle) for the shadow |
| `shadow.camera.left` | Number | The shadow camera left plane |
| `shadow.camera.right` | Number | The shadow camera right plane |
| `shadow.camera.top` | Number | The shadow camera top plane |
| `shadow.camera.bottom` | Number | The shadow camera bottom plane |
| `shadow.bias` | Number | The shadow bias (rules how far the shadow is from the casting object) |
| `shadow.mapSize.width` | Number | The shadow map width |
| `shadow.mapSize.height` | Number | The shadow map height |

Also note that we are creating the light with white color (`0xffffff`), it means this will be a bright light. 

**Target** Finally, it is important to understand that the directional light we just created is pointing to `(0, 0, 0)` (the scene center). Where did we set that? Nowhere! By default, directional lights will always have their targets set at the center.

If we try to run this by invoking the `renderer` as we did before, unfortunately we would still be looking at a black screen. That is because there is no object that our lights are actually hitting. We need to put something in the scene.

## Creating the starfield
We want to create a background of stars. After all we are going to render the universe as our background right? How to we do this? We use a [texture](https://en.wikipedia.org/wiki/Texture_(visual_arts)). 

Textures in 3D graphics can be used for many reasons: mainly for materials. In our specific case, we want to deceive the user by believing we are going to create millions of little shiny stars on the scene, while, in reality, we are going to project an image in the background which shows many stars. Why do we want to do this? Because it is much easier and faster. And when I say faster, I mean faster for the browser. Adding millions of objects on the scene would slow down our animation.

1. In our project's folder, go to `sora/common`.
2. Crete a new file and name it: `starfield.js`.

After creating the file, do the following:

1. Go back to `sora/earth/index.html`.
2. Locate the last import line for `index.js`.
3. Right before that, write down an import for the file we just created.

The line of code you should write is:

{% highlight html %}
<script type="text/javascript" src="../common/starfield.js"></script>
{% endhighlight %}

Now we go back to `starfield.js` and add the following initial content:

{% highlight javascript %}
var sora = sora || {};
sora.starfield = {
  // Here goes our code
};
{% endhighlight %}

We are going to write down the module responsible for creating the starfield. The next lines of code are supposed to be written where the comment tells us to.

### Creating the module
The first thing we need to add to our module is a constant which we'll add in other modules we'll create:

{% highlight javascript %}
urlToImagesFromIndex: "../images/",
{% endhighlight %}

This variable is used as a base address when we will specify the address to the starfield image.

The next lines are needed to define the function which creates the starfield object:

{% highlight javascript %}
createMesh: function () {
  // Function code in here
}
{% endhighlight %}

Inside the function, let's type the following lines now:

{% highlight javascript %}
var loader = new THREE.TextureLoader();
var texture = loader.load(sora.starfield.urlToImagesFromIndex + "galaxy_starfield.png");
{% endhighlight %}

The first line is for creating a [TextureLoader](https://threejs.org/docs/?q=TextureLoader#Reference/Loaders/TextureLoader) object. This object will help us loading images. The second line, uses the loader we created to load an image. Here we are using our base address variable. The base address variable is needed because we are going to call this code from `index.html`, the path to the image must be relative to that page!

Now that we have the image, we can create a material object based on that. Basically we are going to create a sphere and apply the starfield image to its inner surface. Like this we can simulate the universe background. The following lines are as follows:

{% highlight javascript %}
var material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.BackSide
});
{% endhighlight %}

| Parameter | Type | Description |
|----------|:----:|-------------|
| `map` | Object | An object representing, usually, a texture to use as material |
| `side` | Number | Regulates which side of the object surface the material should be applied to |

As you can see, we are creating a material which applies to the back side of the surface it is applied to! We can now create the sphere:

{% highlight javascript %}
var geometry = new THREE.SphereGeometry(100, 32, 32);
{% endhighlight %}

The arguments passed to `THREE.SphereGeometry` are:

| Argument | Type | Description |
|----------|:----:|-------------|
| Radius | Number | The sphere radius |
| Segments width | Number | The width of the elementary segments composing the surface |
| Segments height | Number | The height of the elementary segments composing the surface |

We cannot create a perfect sphere, we need to use little straight surfaces to build it. As a final result the sphere will not be perfectly curved, but it is fine. As long as we keep the segments small compared to the size of the sphere, it is all right. It is the same process we use for building a soccer ball: there we use octagons.

We have the geometry and the material, we can create the final object which is a [Mesh](https://threejs.org/docs/?q=Mesh#Reference/Objects/Mesh):

{% highlight javascript %}
var mesh = new THREE.Mesh(geometry, material);
{% endhighlight %}

We will return the mesh we just created. The code in `starfield.js` should look like this:

{% highlight javascript linenos %}
var sora = sora || {};

sora.starfield = {
  urlToImagesFromIndex: "../images/",

  createMesh: function () {
    var loader = new THREE.TextureLoader();
    var texture = loader.load(sora.starfield.urlToImagesFromIndex + "galaxy_starfield.png");

    var material = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide
    });

    var geometry = new THREE.SphereGeometry(100, 32, 32);
    var mesh = new THREE.Mesh(geometry, material);

    return mesh;
  }
};
{% endhighlight %}

### Using the module
Let's go back to `index.js`. Since we import `starfield.js` and `index.js` both in `index.html`, `index.js` will have access to everything we have written inside `starfield.js`. 

So we basically need to invoke `sora.starfield.createMesh` and then add the object to the scene, it is actually pretty straightforward process, we continue by adding the following lines right after the last ones we typed before leaving the file:

{% highlight javascript %}
var starSphere = sora.starfield.createMesh();
scene.add(starSphere);
{% endhighlight %}

## Creating the Earth system
We now move forward and create the Earth and the Moon. The first thing we wanna do is creating an object which which will serve as a container for both the Earth and the Moon. We basically want to group the 2 planets into an object because we will apply a rotation to the all system. Why? Beause, as you know, the Eaerth's rotation axis has a 23.4 degree inclination.

Let's add the following lines:

{% highlight javascript %}
var containerEarth = new THREE.Object3D();
containerEarth.rotateZ(-23.4 * Math.PI / 180);
containerEarth.position.z = 0;
scene.add(containerEarth);
{% endhighlight %}

We create an object and apply a rotation to the Z axis. The rotation quantity you see is something you can understand if you have studied Trigoniometry: we basically convert 23.4 degrees into radiants. Then we position the object at the center of the coordinate system by setting the z-coordinate to 0. The last line simply adds the object to the scene.

### Creating the Moon
As we did for the starfield, we will create a module for creating the Moon.

1. In our project's folder, go to `sora/common`.
2. Add a new folder: `planets`.
2. Crete a new file inside `planets` and name it: `earth.js`.

After creating the file, do the following:

1. Go back to `sora/earth/index.html`.
2. Locate the last import line for `index.js`.
3. Right before that, write down an import for the file we just created.

The line of code you should write is:

{% highlight html %}
<script type="text/javascript" src="../common/planets/earth.js"></script>
{% endhighlight %}

Now we go back to `earth.js` and add the following initial content:

{% highlight javascript %}
var sora = sora || {};
sora.planets = sora.planets || {};
sora.planets.earth = {
  // Here goes our code
};
{% endhighlight %}

The process is the same as before as you can see. And as we did before, we need to add to our module the base address constant:

{% highlight javascript %}
urlToImagesFromIndex: "../images/",
{% endhighlight %}

The next lines are needed to define the function which creates the Moon object:

{% highlight javascript %}
createMoonMesh: function () {
  // Function code in here
}
{% endhighlight %}

The net code goes into the function. We need to create the geometry:

{% highlight javascript %}
var geometry = new THREE.SphereGeometry(0.5, 32, 32);
{% endhighlight %}

We just created a sphere with a radius of 0.5 and fragment size of 32 (we are using the same fragment size for all objects).

We can move on to defining the material:

{% highlight javascript %}
var loader = new THREE.TextureLoader();
var material = new THREE.MeshPhongMaterial({
  map: loader.load(sora.planets.earth.urlToImagesFromIndex + "moonmap1k.jpg"),
  bumpMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "moonbump1k.jpg"),
  bumpScale: 0.002
});
{% endhighlight %}

We have a few new parameters here:

| Parameter | Type | Description |
|----------|:----:|-------------|
| `map` | Object | An object representing, usually, a texture to use as material |
| `bumpMap` | Object | A testure representing the level map used to create extrusions |
| `bumpScale` | Number | The extrusion factor when a bump map is applied |

We want to create the mountines and craters on the moon, the way to do it, is by means of bump maps. A bump map is a black-and-white of a texture, which tells the renderer which parts of the texture to extrude, and how much they should be extruded. In the bump map, the more white is a region, the more extruded it will be.

We can create the mesh object:

{% highlight javascript %}
var mesh = new THREE.Mesh(geometry, material);
{% endhighlight %}

And after returning it, the code should be the following:

{% highlight javascript linenos %}
var sora = sora || {};
sora.planets = sora.planets || {};

sora.planets.earth = {
  urlToImagesFromIndex: "../images/",

  createMoonMesh: function () {
    var geometry = new THREE.SphereGeometry(0.5, 32, 32);

    var loader = new THREE.TextureLoader();
    var material = new THREE.MeshPhongMaterial({
      map: loader.load(sora.planets.earth.urlToImagesFromIndex + "moonmap1k.jpg"),
      bumpMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "moonbump1k.jpg"),
      bumpScale: 0.002
    });

    var mesh = new THREE.Mesh(geometry, material);

    return mesh;
  }
};
{% endhighlight %}

Back to `index.js`, we can use what we just finished writing:

{% highlight javascript %}
var moonMesh = sora.planets.earth.createMoonMesh();
{% endhighlight %}

But before adding this to the container object, we want to make a few adjustments:

{% highlight javascript %}
moonMesh.position.set(0.5, 0.5, 0.5);
moonMesh.scale.multiplyScalar(1 / 5);
moonMesh.receiveShadow = true;
moonMesh.castShadow = true;
{% endhighlight %}

We are setting the position, not to be at the center (because at the center we will place the Earth), and we are also resizing the Moon to be smaller 5 times (after all the Moon is smaller than the Earth). The last couple of lines instruct the renderer to have the Moon object creare and also receive shadows.

Now we can add the Moon to the container:

{% highlight javascript %}
containerEarth.add(moonMesh);
{% endhighlight %}

### Creating the Earth
Let's focus now on the main character of the story. As before, we need to create the logic for creating the object as we did for the Moon. We will add the `createMesh` function in `earth.js`.

1. Move to `earth.js`.
2. Locate function `createMoonMesh`.
3. Add the following lines before it:

{% highlight javascript %}
createMesh: function () {
  // Our code will go here
},
{% endhighlight %}

As before, we create the geometry:

{% highlight javascript %}
var geometry = new THREE.SphereGeometry(0.5, 32, 32);
{% endhighlight %}

Then the material:

{% highlight javascript %}
var loader = new THREE.TextureLoader();
var material = new THREE.MeshPhongMaterial({
  map: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthmap1k.jpg"),
  bumpMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthbump1k.jpg"),
  bumpScale: 0.05, /* Bump scale factor */
  specularMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthspec1k.jpg")
});
{% endhighlight %}

Here we have a new parameter: `specularMap`. The concept is similar to bump maps, but here we do not regulate the extrusion. Instead we define the shininess. The more white is a region in the specular map, the more shiny it will be as a final result when the object is hit by the light.

After generating the mesh:

{% highlight javascript %}
var mesh = new THREE.Mesh(geometry, material);
{% endhighlight %}

And returning the it, the code should look like this:

{% highlight javascript linenos %}
sora.planets.earth = {
  urlToImagesFromIndex: "../images/",

  createMesh: function () {
    var geometry = new THREE.SphereGeometry(0.5, 32, 32);

    var loader = new THREE.TextureLoader();
    var material = new THREE.MeshPhongMaterial({
    map: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthmap1k.jpg"),
      bumpMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthbump1k.jpg"),
      bumpScale: 0.05, /* Bump scale factor */
      specularMap: loader.load(sora.planets.earth.urlToImagesFromIndex + "earthspec1k.jpg")
    });

    var mesh = new THREE.Mesh(geometry, material);

    return mesh;
  },

  createMoonMesh: function () {
    ...
  }
};
{% endhighlight %}

Back to `index.js`, we can use the code we just wrote and add the following lines:

{% highlight javascript %}
var earthMesh = sora.planets.earth.createMesh();
earthMesh.receiveShadow = true;
earthMesh.castShadow = true;
containerEarth.add(earthMesh);
{% endhighlight %}

Same as when we focused on the Moon! However, we want to add an animation to the Earth: we want the Earth to rotate. So we add the following lines:

{% highlight javascript %}
onRenderFcts.push(function (delta, now) {
  earthMesh.rotation.y += 1 / 32 * delta;
});
{% endhighlight %}

## Creating the atmosphere
We want to create a very cool Earth. One the distinguishing aspects of our planet is its unique atmosphere. How can we create it? In a few steps:

- We create a glowing sphere which will contain the earth.
- We create another glowing sphere where the glowing effect is applied on the backside. This sphere will contain the previous one.
- We create a sphere with a cloud texture rotating around.

### Creating the inner glow
Let's start with the inner glowing sphere, let's add the following lines in `index.js`:

{% highlight javascript %}
var innerAtmoGeometry = new THREE.SphereGeometry(0.5, 32, 32);
{% endhighlight %}

Next step is using one of our preset assets:

{% highlight javascript %}
var innerAtmoMaterial = sora.shader.createAtmosphereMaterial();
{% endhighlight %}

The glowing material is a bit more complex to create as it involves the use of something called shader. The shader is one of the core components of the WebGL technology and we cannot deal with it here unfortunately. The previous line basically gives us a material we can work on. Next step is making a few adjustments:

{% highlight javascript %}
innerAtmoMaterial.uniforms.glowColor.value.set(0x00b3ff);
innerAtmoMaterial.uniforms.coeficient.value = 0.8;
innerAtmoMaterial.uniforms.power.value = 2.0;
{% endhighlight %}

The shader we have just used defines 3 parameters: `glowColor`, `coeficient` and `power`. Those 3 are used to compute the final glow effect. How this glow effect is created, is not simple to understand unless we have a general understanding of vectors and matrices. So we will not go deeper into this matter, but we can explain a few things about these parameters:

| Parameter | Type | Description |
|----------|:----:|-------------|
| `glowColor` | Number (hex) | The color of the glow |
| `coeficient` | Number | Used to calculate the glow intensity. The higher the value, the higher the intensity |
| `power` | Number | Used to calculate the glow intensity. The higher the value, the higher the intensity (exponential growth) |

The next lines finalize the inner atmosphere:

{% highlight javascript %}
var innerAtmoMesh = new THREE.Mesh(innerAtmoGeometry, innerAtmoMaterial);
innerAtmoMesh.scale.multiplyScalar(1.01);
containerEarth.add(innerAtmoMesh);
{% endhighlight %}

The first line creates the mesh, the second line makes the mesh just a little big bigger so that it can contain the earth by a little margin. The last line, of course, adds the mesh to the container.

### Creating the outer glow
The process for creating the second glow (the second atmosphere) is the same. We will just use different values for the shader parameters and apply the material to the backside of the sphere. We start from the same point: we create the geometry:

{% highlight javascript %}
var outerAtmoGeometry = new THREE.SphereGeometry(0.5, 32, 32);
{% endhighlight %}

As before, we use the shader for getting the material:

{% highlight javascript %}
var outerAtmoMaterial = sora.shader.createAtmosphereMaterial();
{% endhighlight %}

We then make almost the same adjustments:

{% highlight javascript %}
outerAtmoMaterial.side = THREE.BackSide;
outerAtmoMaterial.uniforms.glowColor.value.set(0x00b3ff);
outerAtmoMaterial.uniforms.coeficient.value = 0.5;
outerAtmoMaterial.uniforms.power.value = 4.0;
{% endhighlight %}

As you can see, we have given different values to the parameters and also applied the material to the backside of the surface of the object the material will be applied to. The values we gave will make the glow different from the one of the inner atmosphere. The final effect will be a somewhat translucent glow.

The next lines finalize the outer atmosphere:

{% highlight javascript %}
var outerAtmoMesh = new THREE.Mesh(outerAtmoGeometry, outerAtmoMaterial);
outerAtmoMesh.scale.multiplyScalar(1.15);
containerEarth.add(outerAtmoMesh);
{% endhighlight %}

As you can see, this atmosphere will contain the previous one as we make it a big bigger.

## Creating clouds
Clouds make our planet unique. We are not just the blue planet, we are the planet with white moving clouds. Clouds are also the last step for us, after that we will be ready to add a few more animations and that's it.

Clouds are not easy to create. We need to do the following:

- Use a texture to apply to a sphere.
- Create a material out of the texture and extrude it using a bump map.
- Apply the material to both sides of the sphere to create a two-layered effect.
- Make the atmosphere rotate.

So you see, there is a lot here. In order to keep this tutorial short, we are going to use a preset code. So we will not worry about this process.

To create clouds, we need to create a module:

1. Move to `earth.js`.
2. Locate function `createMoonMesh`.
3. Add a comma after the closing function bracket.
3. Add the following lines after it:

{% highlight javascript %}
createCloudMesh: function () {
  // Our code will end in here
}
{% endhighlight %}

The code for this unction is very simple: we just call `sora.utils.createCloudMes` which has the logic for generating clouds. We have imported `utils.js` in `index.js` (together with `earth.js`), so we can assume the code in `utils.js` will be available here as well.

We add the following code:

{% highlight javascript %}
return sora.utils.createCloudMesh(
  sora.planets.earth.urlToImagesFromIndex + "earthcloudmaptrans.jpg",
  sora.planets.earth.urlToImagesFromIndex + "earthcloudmap.jpg");
{% endhighlight %}

The module should look like this now:

{% highlight javascript linenos %}
sora.planets.earth = {
  urlToImagesFromIndex: "../images/",

  createMesh: function () {
    ...
  },

  createMoonMesh: function () {
    ...
  },

  createCloudMesh: function () {
    return sora.utils.createCloudMesh(
      sora.planets.earth.urlToImagesFromIndex + "earthcloudmaptrans.jpg",
      sora.planets.earth.urlToImagesFromIndex + "earthcloudmap.jpg");
  }
};
{% endhighlight %}

The Earth module is completed! Note that, as the name indicates, `sora.utils.createCloudMesh` returns a mesh. Let's go back to `index.js` and add the following lines:

{% highlight javascript %}
var earthCloud = sora.planets.earth.createCloudMesh();
earthCloud.receiveShadow = true;
earthCloud.castShadow = true;
containerEarth.add(earthCloud);
{% endhighlight %}

Since `sora.planets.earth.createCloudMesh` also returns a mesh, we can just instruct the renderer so that shadows as well can cast and receive shadows, after that we just need to add clouds to the container.

The last lines are needed for adding a rotation animation to clouds:

{% highlight javascript %}
onRenderFcts.push(function (delta, now) {
  earthCloud.rotation.y += 1 / 8 * delta;
})
{% endhighlight %}
