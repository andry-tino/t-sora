---
layout: post
title:  "Tutorial"
date:   2016-10-16 19:13:00 +0000
categories: post
description: Main tutorial for building a cross platform app
---
# Building a 3D Earth and Moon animation
In this tutorial you will learn how to use [HTML5](https://en.wikipedia.org/wiki/HTML5), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), the [WebGL API](https://en.wikipedia.org/wiki/WebGL) and the [THREE library](https://threejs.org/) to create a 3D animation in your browser.

## Requirements
For this tutorial you are going to need:

1. An Internet browser. [Chrome](https://www.google.com/chrome/browser/desktop/index.html) is recommended because it has an easy way to disable [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) and a tutorial is provided here for that.
2. A text editor. [Visual Studio Code](https://code.visualstudio.com) is recommended because it has very good code highlight features and can be installed on all systems.

**Important** The browser you use must be updated to the latest version. We are going to use some very new functionalities introduced lately, so we need the latest version.

## A few things first...
Creating a 3D animation using Javascript and the WebGL API requires some code. In particular there is a lot of code for setting the basic stuff needed for whatever 3D project, namely a scene, a camera and some lights. Setting all these initial things together takes a lot of time and the WebGL API are very low level (every single point in a mesh is to be defined and a lot of matrix calculus is involved).

**THREE.js to the rescue** For this reason, we use a high level library called [THREE.js](https://threejs.org/) which hides all the mathematics behind objects and animations and lets us focus on the cool things. Thanks to this library, we are going to write much shorter code, making it easy to create objects and animate them.

**Preset pieces** Another detail to be aware of is that we are going to use a few snippets of code already prepared for you for some functionalities we are going to need. We could go though this code and build it together, but that would require some more time spent on a few minor things we don't want to focus on in the context of this tutorial. So we are just going to import and use it and that's all!

This tutorial also comes with some images we are going to use as well. They are going to be required once we start defining the material of the objects we'll create later.

## Defining the project structure
We start by creating the project structure with the folders and files we are going to need.

1. Go to this tutorial's source [Releases Git page](https://github.com/andry-tino/t-sora/releases).
2. Locate the latest Tutorial Kit and click on it.
3. In `Downloads`, locate the kit package (the other links contain the source code, don't choose them).
4. In your system, locate a place where you want to create the project. Usually your user's home folder in Linux and iOS, or the `Documents` folder in Windows are good choices.
2. Extract the package content there.

You should end up having the following folder structure:

```
+sora
|--+common
   |--shading.js
   |--utils.js
|--+deps
   |--three.js
|--+images
```

### Preset files
This is our start point. Inside the `sora` folder, there is all we need to start building our project.

| Path | Type | Description |
|------|:----:|-------------|
| `sora/common` | Folder | Contains all the common resources we will need |
| `sora/deps`   | Folder | Contains external libraries |
| `sora/images` | Folder | Contains the images and textures we need for materials |
| `common/shading.js` | JavaScript source | Has functions we will use for special 3D effects |
| `common/utils.js` | JavaScript source | Has some JavaScript utility functions for creating some complicated objects |
| `deps/three.js` | JavaScript source | The [THREE library](https://threejs.org/) |

### Completing the structure
The tutorial kit we just unpacked contains the initial set of folders and files we need. Now we need to start adding our stuff as, in this condition, we just have a few building blocks which do nothing.

#### Defining the homepage
We need to create the homepage of our project which will display the animation.

1. In your system, naivgate to directory `sora`.
2. Inside it, create a new directory called `earth`.
3. Inside `earth`, create 3 files called: `index.html`, `index.js` and `index.css`. Leave the files empty.

The folder structure should look like the following:

```
+sora
|--+earth
   |--index.html
   |--index.js
   |--index.css
```

We have basically created the initial structure for the homepage:

| File | Type | Description |
|------|:----:|-------------|
| `index.html` | HTML file | The homepage hosting the 3D animation |
| `index.js`   | JavaScript source file | The JavaScript source which will contain the code for creating the animation |
| `index.css` | CSS style source file | The style file for setting a few properties of the homepage |

#### Adding content
Let's now open `index.html`, and let's write the most basic HTML structure that every page needs to be correctly displayed in a browser:

{% highlight html linenos %}
<html>
  <head>
    <title>My first Three.js app</title>
  </head>
  <body>
	
  </body>
</html>
{% endhighlight %}

If you open this page in your browser, you will see just a blank page. We need to add some more stuff into it. So, inside the `<head>` tag, just under the `<title>`, add this line:

{% highlight html %}
<meta http-equiv="Access-Control-Allow-Origin" content="*">
{% endhighlight %}

This line is not simple to explain. For now, let's say that we need it in order to see the 3D animation once we create it. The browser will not authorize the 3D rendering without this line because of some secutity-related issues. This line will allow us to run the animation and see it on the browser.

We now need to add a reference to `index.css`, our stylesheet. So after the line we just typed, let's add these lines:

{% highlight html %}
<!-- The basic page style -->
<link rel="stylesheet" type="text/css" href="style.css">
{% endhighlight %}

This will allow us to import the content of `index.css` into our page.

Next step is to import some JavaScript files, we need to import `index.js`, `shading.js` and `utils.js` (the last 2 reside in the `common` folder). So let's add these lines after the lines we entered before:

{% highlight html %}
<!-- Stuff we need: external libraries and help scripts -->
<script type="text/javascript" src="../deps/three.js"></script>
<script type="text/javascript" src="../common/utils.js"></script>
<script type="text/javascript" src="../common/shading.js"></script>
{% endhighlight %}

We have imported the THREE library and some other files we will need later. However, we are missing one file: `index.js` which we need to import because, later, we will add the JavaScript code for the animation there. So let's add this final line of code after those we have just written a while ago:

{% highlight html %}
<!-- Our code -->
<script type="text/javascript" src="index.js"></script>
{% endhighlight %}

We are done for now with `index.html` which should look like this:

{% highlight html linenos %}
<html>
  <head>
    <title>My first Three.js app</title>

    <!-- The basic page style -->
    <link rel="stylesheet" type="text/css" href="style.css">

    <!-- Stuff we need: external libraries and help scripts -->
    <script type="text/javascript" src="../deps/three.js"></script>
    <script type="text/javascript" src="../common/utils.js"></script>
    <script type="text/javascript" src="../common/shading.js"></script>

    <!-- Our code -->
    <script type="text/javascript" src="index.js"></script>
  </head>
  <body>

  </body>
</html>
{% endhighlight %}

### A few styling settings
Before deep diving into the JavaScript code, let's first make sure that the 3D scenen we are going to build takes all the browser window's size. To do so, let's open `index.css` (which we just imported into `index.html`) and type in the following code:

{% highlight css linenos %}
body {
  margin: 0;
}

canvas { 
  width: 100%; 
  height: 100%;
}
{% endhighlight %}

This instructs the browser not to create the border margin. Also it instructs it to make the `<canvas>` element fill the entire space once we place it there. The `<canvas>` is something we are going to create later, basically it will contain the 3D world we are going to create.

## Building the 3D scene
Now that `index.html` is importing everything we need and we also have the correct style in place, we can start writing down the logic for building the animation. So, we start by opening `index.js` and typing in the following lines:

{% highlight javascript %}
window.addEventListener("load", function() {
  // Our code goes here
});
{% endhighlight %}

Function `addEventListener` will wait that the page loads before running the code inside the anonymous function passed in as second argument. As the comment is showing, we will write our code inside that anonymous function, so that we are certain that the page has finished loading all the imports and the style, before we create our 3D scene.

### Creating the renderer
We start by creating an instance of the [WebGL Renderer](https://threejs.org/docs/api/renderers/WebGLRenderer.html). The renderer is the component responsible for drawing the 3D scene. It is a pretty complex entity as it does all the magic. The renderer is responsible for:

- Drawing the scene.
- Drawing the objects in a scene.
- Evaluate materials.
- Evaluate light sources and shadows.
- Run a complex algorithm which calculates the amount of light on surfaces depending on the light sources and how light reflects on surfaces.

We create a renderer by invoking this command (we type it inside the anonymous function):

{% highlight javascript %}
var renderer = new THREE.WebGLRenderer({
  antialias : true
});
{% endhighlight %}

Variable `renderer` will host the component. Note that we set antialiasing so that the quality of our animation is higher.
The next three lines of code are as follows:

{% highlight javascript %}
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
{% endhighlight %}

In the first one we set the size of the scene basically, we make it span the whole window (both horizontally and vertically). The second line is actually adding the renderer to the page. If we do not add the renderer to the page, we won't be seeing anything otherwise. The last line will enable shadows.

Before moving to the next component, we need to create an array:

{% highlight javascript %}
var onRenderFcts = [];
{% endhighlight %}

This array will be used later and is very important as it will host the functions that the renderer should call in order to run the final animation.

### Creating the scene
We cannot create objects inside the renderer, we need to create a scene and add it to the renderer first. Later on, we will add objects to the scene.

{% highlight javascript %}
var scene = new THREE.Scene();
{% endhighlight %}

Now that the scene is ready, we can create a camera. If we do not create a camera, we cannot nothing on the screen. Cameras are the objects necessary to visualize whatever we place in a scene.

{% highlight javascript %}
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.z = 1;
{% endhighlight %}

The parameters we just passed to the [PerspectiveCamera](https://threejs.org/docs/api/cameras/PerspectiveCamera.html) object are the following (in order from left to right):

| Argument | Type | Description |
|----------|:----:|-------------|
| Frustum length | Number | The field volume that the camera captures. The camera will visualize only the objects falling into this volume |
| Perspective | Number | The perspective ratio |
| Frustum near plane | Number | The frustum plane which is closest to the viewpoint |
| Frustum far plane | Number |  The frustum plane which is farthest to the viewpoint |

The second line makes sure that the camera is positioned one unit above the base plane.

### Let's try to run it!
What if we wanted to see the effect of what we are building? Well, the only thing we need to do is telling `renderer` to paint the scene from a camera. Type the following line of code, save and then run the page in the browser:

{% highlight javascript %}
renderer.render(scene, camera);
{% endhighlight %}

What can you see? I bet you get a black screen :) We'll get to that, for now just remove the last line you wrote!

## Lighting it up
We have a scene and we also have a camera. But if we run this we are going to see only a black screen. Why? Because we are missing the most important thing when it comes to 3D computing: light. With no light, we only have darkness.

Following from the last line of code we wrote in the previous section, we now add these lines:

{% highlight javascript %}
var light = new THREE.AmbientLight(0x222222);
scene.add(light);
{% endhighlight %}

We are creating, in the first line, an [AmbientLight](https://threejs.org/docs/api/lights/AmbientLight.html) object. Think of this as an omnidirectional light. We are setting this to be a dark light because we want our background to be dark, the universe is not so bright after all. The last line is adding the light to the scene.

Our next step is creating a directional light which will point to the planet we will create later. A directional light is like a flashlight, so we will need to specify direction and intensity:

{% highlight javascript linenos %}
light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
light.castShadow = true;
light.shadow.camera.near = 0.01;
light.shadow.camera.far = 15;
light.shadow.camera.fov = 45;
light.shadow.camera.left = -1;
light.shadow.camera.right = 1;
light.shadow.camera.top = 1;
light.shadow.camera.bottom = -1;
light.shadow.bias = 0.001;
light.shadow.mapSize.width = 1024;
light.shadow.mapSize.height = 1024;
scene.add(light);
{% endhighlight %}

As you can see, the code we just wrote is setting a few properties for this [DirectionalLight](https://threejs.org/docs/api/lights/DirectionalLight.html) object:

| Property | Type | Description |
|----------|:----:|-------------|
| `position` | Coordinates | The point were the light will be placed |
| `castShadow` | Boolean | Should the light cast shadows? |
| `shadow.camera.near` | Number | The near plane defining the frustum of the shadow |
| `shadow.camera.far` | Number | The far plane defining the frustum of the shadow |
| `shadow.camera.fov` | Number | The field of view (vertical angle) for the shadow |
| `shadow.camera.left` | Number | The shadow camera left plane |
| `shadow.camera.right` | Number | The shadow camera right plane |
| `shadow.camera.top` | Number | The shadow camera top plane |
| `shadow.camera.bottom` | Number | The shadow camera bottom plane |
| `shadow.bias` | Number | The shadow bias (rules how far the shadow is from the casting object) |
| `shadow.mapSize.width` | Number | The shadow map width |
| `shadow.mapSize.height` | Number | The shadow map height |

Also note that we are creating the light with white color (`0xffffff`), it means this will be a bright light. 

**Target** Finally, it is important to understand that the directional light we just created is pointing to `(0, 0, 0)` (the scene center). Where did we set that? Nowhere! By default, directional lights will always have their targets set at the center.

If we try to run this by invoking the `renderer` as we did before, unfortunately we would still be looking at a black screen. That is because there is no object that our lights are actually hitting. We need to put something in the scene.

## Creating the starfield
We want to create a background of stars. After all we are going to render the universe as our background right? How to we do this? We use a [texture](https://en.wikipedia.org/wiki/Texture_(visual_arts)). 

Textures in 3D graphics can be used for many reasons: mainly for materials. In our specific case, we want to deceive the user by believing we are going to create millions of little shiny stars on the scene, while, in reality, we are going to project an image in the background which shows many stars. Why do we want to do this? Because it is much easier and faster. And when I say faster, I mean faster for the browser. Adding millions of objects on the scene would slow down our animation.

1. In our project's folder, go to `sora/common`.
2. Crete a new file and name it: `starfield.js`.

After creating the file, do the following:

1. Go back to `sora/earth/index.html`.
2. Locate the last import line for `index.js`.
3. Right before that, write down an import for the file we just created.

The line of code you should write is:

{% highlight html %}
<script type="text/javascript" src="../common/starfield.js"></script>
{% endhighlight %}

Now we go back to `starfield.js` and add the following initial content:

{% highlight javascript %}
var sora = sora || {};
sora.starfield = {
  // Here goes our code
};
{% endhighlight %}

We are going to write down the module responsible for creating the starfield. The next lines of code are supposed to be written where the comment tells us to.

### Creating the module
The first thing we need to add to our module is a constant which we'll add in other modules we'll create:

{% highlight javascript %}
urlToImagesFromIndex: "../images/",
{% endhighlight %}

This variable is used as a base address when we will specify the address to the starfield image.

The next lines are needed to define the function which creates the starfield object:

{% highlight javascript %}
createMesh: function () {
  // Function code in here
}
{% endhighlight %}

Inside the function, let's type the following lines now:

{% highlight javascript %}
var loader = new THREE.TextureLoader();
var texture = loader.load(sora.starfield.urlToImagesFromIndex + "galaxy_starfield.png");
{% endhighlight %}

The first line is for creating a [TextureLoader](https://threejs.org/docs/?q=TextureLoader#Reference/Loaders/TextureLoader) object. This object will help us loading images. The second line, uses the loader we created to load an image. Here we are using our base address variable. The base address variable is needed because we are going to call this code from `index.html`, the path to the image must be relative to that page!

Now that we have the image, we can create a material object based on that. Basically we are going to create a sphere and apply the starfield image to its inner surface. Like this we can simulate the universe background. The following lines are as follows:

{% highlight javascript %}
var material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.BackSide
});
{% endhighlight %}

As you can see, we are creating a material which applies to the back side of the surface it is applied to! We can now create the sphere:

{% highlight javascript %}
var geometry = new THREE.SphereGeometry(100, 32, 32);
{% endhighlight %}

The arguments passed to `THREE.SphereGeometry` are:

| Argument | Type | Description |
|----------|:----:|-------------|
| Radius | The sphere radius |
| Segments width | Number | The width of the elementary segments composing the surface |
| Segments height | Number | The height of the elementary segments composing the surface |

We cannot create a perfect sphere, we need to use little straight surfaces to build it. As a final result the sphere will not be perfectly curved, but it is fine. As long as we keep the segments small compared to the size of the sphere, it is all right. It is the same process we use for building a soccer ball: there we use octagons.

We have the geometry and the material, we can create the final object which is a [Mesh](https://threejs.org/docs/?q=Mesh#Reference/Objects/Mesh):

{% highlight javascript %}
var mesh = new THREE.Mesh(geometry, material);
{% endhighlight %}

We will return the mesh we just created. The code in `starfield.js` should look like this:

{% highlight javascript linenos %}
var sora = sora || {};

sora.starfield = {
  urlToImagesFromIndex: "../images/",

  createMesh: function () {
    var loader = new THREE.TextureLoader();
    var texture = loader.load(sora.starfield.urlToImagesFromIndex + "galaxy_starfield.png");

    var material = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide
    });

    var geometry = new THREE.SphereGeometry(100, 32, 32);
    var mesh = new THREE.Mesh(geometry, material);

    return mesh;
  }
};
{% endhighlight %}

### Using the module
Let's go back to `index.js`. Since we import `starfield.js` and `index.js` both in `index.html`, `index.js` will have access to everything we have written inside `starfield.js`. 

So we basically need to invoke `sora.starfield.createMesh` and then add the object to the scene, it is actually pretty straightforward process, we continue by adding the following lines right after the last ones we typed before leaving the file:

{% highlight javascript %}
var starSphere = sora.starfield.createMesh();
scene.add(starSphere);
{% endhighlight %}


